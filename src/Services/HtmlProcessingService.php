<?php

namespace Prasso\BedrockHtmlEditor\Services;

use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use voku\helper\HtmlMin;
use DOMDocument;
use DOMXPath;
use App\Models\Site;
use App\Models\SitePages;

class HtmlProcessingService
{
    protected BedrockAgentService $bedrockService;
    protected S3StorageService $s3StorageService;
    protected array $config;

    public function __construct(BedrockAgentService $bedrockService, S3StorageService $s3StorageService = null)
    {
        $this->bedrockService = $bedrockService;
        $this->s3StorageService = $s3StorageService ?? new S3StorageService();
        $this->config = config('bedrock-html-editor');
    }

    /**
     * Modify existing HTML content based on user prompt
     *
     * @param string $html
     * @param string $prompt
     * @param string|null $sessionId
     * @return array
     */
    public function modifyHtml(string $html, string $prompt, ?string $sessionId = null): array
    {
        try {
            // Validate input HTML size
            if (strlen($html) > $this->config['html_processing']['max_html_size']) {
                return [
                    'success' => false,
                    'error' => 'HTML content exceeds maximum allowed size',
                ];
            }

            // Check if HTML is empty
            if (empty(trim($html))) {
                return [
                    'success' => false,
                    'error' => 'Empty HTML content provided for modification',
                ];
            }

            // Validate HTML structure
            $validationResult = $this->validateHtml($html);
            if (!$validationResult['valid']) {
                Log::warning('Invalid HTML provided for modification', [
                    'errors' => $validationResult['errors'],
                ]);
                // Continue with the process even if validation fails
            }

            // Prepare prompt using template from configuration
            $promptTemplate = $this->config['prompts']['modify_html'] ?? "You are an expert HTML/CSS developer. I need you to modify the following HTML content based on these instructions. Please ensure the output is valid HTML and maintains the structure and functionality of the original content.\n\nHTML to modify:\n{html}\n\nInstructions: {prompt}\n\nPlease provide only the modified HTML without any explanation or markdown formatting.";
            $fullPrompt = str_replace(['{html}', '{prompt}'], [$html, $prompt], $promptTemplate);
            
            // Send to Bedrock model directly
            $response = $this->bedrockService->invokeModel(
                $fullPrompt,
                $sessionId
            );
    
            if (!$response['success']) {
                return $response;
            }
            
            // Check if completion is empty
            if (empty($response['completion'])) {
                Log::warning('Empty completion received from agent');
                return [
                    'success' => false,
                    'error' => 'No content was generated by the AI agent',
                ];
            }

            $modifiedHtml = $this->extractHtmlFromResponse($response['completion']);
            
            // Check if extracted HTML is empty
            if (empty(trim($modifiedHtml))) {
                Log::warning('No HTML content extracted from agent response');
                return [
                    'success' => false,
                    'error' => 'Failed to extract HTML content from agent response',
                    'raw_response' => substr($response['completion'], 0, 500) // Log a portion of the raw response
                ];
            }

            // Sanitize output if enabled
            if ($this->config['html_processing']['sanitize_output']) {
                $modifiedHtml = $this->sanitizeHtml($modifiedHtml);
            }

            // Minify output if enabled
            if ($this->config['html_processing']['minify_output']) {
                $modifiedHtml = $this->minifyHtml($modifiedHtml);
            }

            // Save modification history if site_id and page_id are provided in metadata
            $metadata = $response['metadata'] ?? [];
            if (isset($metadata['site_id'])) {
                try {
                    $title = 'HTML Modification: ' . substr($prompt, 0, 50) . '...';
                    $this->saveModificationHistory(
                        $metadata['site_id'],
                        $metadata['page_id'] ?? null,
                        $title,
                        $prompt,
                        $html, // original HTML
                        $modifiedHtml,
                        $response['session_id'] ?? $sessionId,
                        $metadata
                    );
                    Log::info('Modification history saved successfully');
                } catch (\Exception $e) {
                    Log::error('Failed to save modification history', [
                        'error' => $e->getMessage()
                    ]);
                }
            } else {
                Log::info('Modification history feature is not implemented yet');
            }

            // Validate the modified HTML
            $modifiedValidation = $this->validateHtml($modifiedHtml);

            return [
                'success' => true,
                'original_html' => $html,
                'modified_html' => $modifiedHtml,
                'prompt' => $prompt,
                'session_id' => $response['session_id'] ?? null,
                'validation' => $modifiedValidation,
                'size_before' => strlen($html),
                'size_after' => strlen($modifiedHtml),
            ];

        } catch (\Exception $e) {
            Log::error('Error during HTML modification', [
                'error' => $e->getMessage(),
                'prompt' => $prompt,
                'html_length' => strlen($html),
            ]);

            return [
                'success' => false,
                'error' => 'Failed to modify HTML: ' . $e->getMessage(),
            ];
        }
    }

    /**
     * Create new HTML content based on user prompt
     *
     * @param string $prompt
     * @param string|null $sessionId
     * @return array
     */
    public function createHtml(string $prompt, ?string $sessionId = null): array
    {
        try {
            // Prepare prompt using template from configuration
            $promptTemplate = $this->config['prompts']['create_html'] ?? "You are an expert HTML/CSS developer. I need you to create a new HTML webpage based on the following requirements. Please create a complete, valid HTML document with proper structure, semantic markup, and inline CSS styling.\n\nRequirements: {prompt}\n\nPlease provide only the HTML code without any explanation or markdown formatting.";
            $fullPrompt = str_replace('{prompt}', $prompt, $promptTemplate);
            
            // Send to Bedrock model directly
            $response = $this->bedrockService->invokeModel($fullPrompt, $sessionId);

            if (!$response['success']) {
                return $response;
            }

            $html = $this->extractHtmlFromResponse($response['completion']);

            // Sanitize output if enabled
            if ($this->config['html_processing']['sanitize_output']) {
                $html = $this->sanitizeHtml($html);
            }

            // Minify output if enabled
            if ($this->config['html_processing']['minify_output']) {
                $html = $this->minifyHtml($html);
            }

            // Validate the created HTML
            $validation = $this->validateHtml($html);

            return [
                'success' => true,
                'html' => $html,
                'prompt' => $prompt,
                'session_id' => $response['session_id'] ?? null,
                'validation' => $validation,
                'size' => strlen($html),
            ];

        } catch (\Exception $e) {
            Log::error('Error during HTML creation', [
                'error' => $e->getMessage(),
                'prompt' => $prompt,
            ]);

            return [
                'success' => false,
                'error' => 'Failed to create HTML: ' . $e->getMessage(),
            ];
        }
    }

    /**
     * Extract HTML content from model response
     *
     * @param string $response
     * @return string
     */
    protected function extractHtmlFromResponse(string $response): string
    {
        // Log the raw response for debugging
        Log::debug('Extracting HTML from response', [
            'response_length' => strlen($response),
            'response_preview' => substr($response, 0, 100) . '...'
        ]);
        
        // Try to extract HTML between code blocks if present
        if (preg_match('/```(?:html)?\s*(.+?)\s*```/s', $response, $matches)) {
            Log::info('Extracted HTML from code block');
            $html = $matches[1];
        }
        // Try to extract HTML between tags if present
        else if (preg_match('/<html.*?>.*?<\/html>/s', $response, $matches)) {
            Log::info('Extracted complete HTML document');
            $html = $matches[0];
        }
        // Try to extract HTML body content if present
        else if (preg_match('/<body.*?>(.+?)<\/body>/s', $response, $matches)) {
            Log::info('Extracted HTML body content');
            $html = $matches[1];
        }
        // Check if response starts with a tag
        else if (preg_match('/^\s*<[a-z][^>]*>/i', $response)) {
            Log::info('Response appears to be raw HTML');
            $html = $response;
        }
        // Return the raw response if no HTML patterns found
        else {
            Log::info('No HTML patterns found, using raw response');
            $html = $response;
        }
        
        // If still empty after extraction, return a placeholder
        if (empty($html)) {
            Log::warning('No HTML content extracted from response');
            return '<div>No valid HTML content was extracted. Please try again with a different prompt.</div>';
        }

        // If no HTML tags detected, wrap in basic HTML structure
        if (!preg_match('/<html|<HTML/', $html)) {
            if (!preg_match('/<body|<BODY/', $html)) {
                $html = "<html>\n<head>\n<title>Generated Page</title>\n</head>\n<body>\n{$html}\n</body>\n</html>";
            }
        }

        return $html;
    }

    /**
     * Validate HTML structure and content
     *
     * @param string $html
     * @return array
     */
    public function validateHtml(string $html): array
    {
        $errors = [];
        $warnings = [];

        try {
            // Check if HTML is empty
            if (empty(trim($html))) {
                $errors[] = 'HTML content is empty';
                return [
                    'valid' => false,
                    'errors' => $errors,
                    'warnings' => $warnings,
                ];
            }
            
            // Create DOMDocument for validation
            $dom = new DOMDocument('1.0', 'UTF-8');
            $dom->validateOnParse = true;
            
            // Suppress warnings for validation
            libxml_use_internal_errors(true);
            
            // Add UTF-8 encoding declaration and wrap content if it doesn't have html/body tags
            $htmlToValidate = $html;
            if (!preg_match('/<html|<HTML/', $html)) {
                $htmlToValidate = '<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body>' . $html . '</body></html>';
            }
            
            $dom->loadHTML($htmlToValidate, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
            
            $libxmlErrors = libxml_get_errors();
            foreach ($libxmlErrors as $error) {
                if ($error->level === LIBXML_ERR_ERROR || $error->level === LIBXML_ERR_FATAL) {
                    $errors[] = trim($error->message);
                } else {
                    $warnings[] = trim($error->message);
                }
            }
            
            libxml_clear_errors();
            libxml_use_internal_errors(false);

            // Check for disallowed tags
            $xpath = new DOMXPath($dom);
            $allElements = $xpath->query('//*');
            
            foreach ($allElements as $element) {
                $tagName = strtolower($element->nodeName);
                if (!in_array($tagName, $this->config['html_processing']['allowed_tags'])) {
                    $errors[] = "Tag {$tagName} invalid";
                }
            }

            // Check for inline scripts (potential security risk)
            $scripts = $xpath->query('//script[not(@src)]');
            if ($scripts->length > 0) {
                $warnings[] = 'Inline scripts detected - potential security risk';
            }

            // Check for inline event handlers
            $eventHandlers = $xpath->query('//*[@onclick or @onload or @onerror or @onmouseover]');
            if ($eventHandlers->length > 0) {
                $warnings[] = 'Inline event handlers detected - potential security risk';
            }

        } catch (\Exception $e) {
            $errors[] = 'Failed to parse HTML: ' . $e->getMessage();
        }

        return [
            'valid' => empty($errors),
            'errors' => array_unique($errors),
            'warnings' => array_unique($warnings),
        ];
    }

    /**
     * Sanitize HTML content
     *
     * @param string $html
     * @return string
     */
    protected function sanitizeHtml(string $html): string
    {
        try {
            // Check if HTML is empty
            if (empty(trim($html))) {
                Log::warning('Empty HTML content provided for sanitization');
                return '<div>No HTML content to sanitize</div>';
            }
            
            $dom = new DOMDocument('1.0', 'UTF-8');
            libxml_use_internal_errors(true);
            
            // Add UTF-8 encoding declaration and wrap content if it doesn't have html/body tags
            if (!preg_match('/<html|<HTML/', $html)) {
                $html = '<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body>' . $html . '</body></html>';
            }
            
            // Load HTML with options to handle HTML5 tags
            $dom->loadHTML($html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
            
            $xpath = new DOMXPath($dom);

            // Check if script tags should be preserved based on config
            $preserveScripts = $this->config['html_processing']['preserve_scripts'] ?? false;
            
            // Remove potentially dangerous elements, but conditionally handle scripts
            $dangerousQuery = $preserveScripts 
                ? '//object | //embed | //iframe[not(@src)]' 
                : '//script[not(@src)] | //object | //embed | //iframe[not(@src)]';
                
            $dangerousElements = $xpath->query($dangerousQuery);
            foreach ($dangerousElements as $element) {
                $element->parentNode->removeChild($element);
            }

            // Remove dangerous attributes
            $allElements = $xpath->query('//*');
            foreach ($allElements as $element) {
                /** @var \DOMElement $element */
                $attributesToRemove = [];
                foreach ($element->attributes as $attr) {
                    if (strpos($attr->name, 'on') === 0) { // onclick, onload, etc.
                        $attributesToRemove[] = $attr->name;
                    }
                }
                
                foreach ($attributesToRemove as $attrName) {
                    $element->removeAttribute($attrName);
                }
            }

            libxml_clear_errors();
            libxml_use_internal_errors(false);
            
            // Extract body content if we wrapped it earlier
            $result = $dom->saveHTML();
            if (preg_match('/<body>(.*?)<\/body>/s', $result, $matches)) {
                return $matches[1];
            }
            
            return $result;

        } catch (\Exception $e) {
            Log::error('HTML sanitization failed: ' . $e->getMessage(), [
                'html_length' => strlen($html)
            ]);
            // Return a basic div with error message instead of the original HTML
            return '<div class="error-message">Error processing HTML content</div>';
        }
    }

    /**
     * Minify HTML content
     *
     * @param string $html
     * @return string
     */
    protected function minifyHtml(string $html): string
    {
        try {
            $htmlMin = new HtmlMin();
            $htmlMin->doOptimizeViaHtmlDomParser(true);
            $htmlMin->doRemoveComments(true);
            $htmlMin->doSumUpWhitespace(true);
            $htmlMin->doRemoveWhitespaceAroundTags(true);
            
            return $htmlMin->minify($html);
        } catch (\Exception $e) {
            Log::warning('HTML minification failed, returning original', [
                'error' => $e->getMessage()
            ]);
            return $html;
        }
    }

    /**
     * Save HTML content to storage
     *
     * @param string $html
     * @param string $filename
     * @param int $siteId
     * @param array $metadata
     * @return array
     */
    public function saveHtml(string $html, string $filename, int $siteId, array $metadata = []): array
    {
        return $this->s3StorageService->storeHtml($html, $filename, $siteId, $metadata);
    }

    /**
     * Load HTML content from storage
     *
     * @param string $path
     * @return array
     */
    public function loadHtml(string $path): array
    {
        return $this->s3StorageService->retrieveHtml($path);
    }
    
    /**
     * Save HTML content for a specific site page
     *
     * @param string $html
     * @param int $siteId
     * @param int $pageId
     * @param array $metadata
     * @return array
     */
    public function savePageHtml(string $html, int $siteId, int $pageId, array $metadata = []): array
    {
        return $this->s3StorageService->storePageHtml($html, $siteId, $pageId, $metadata);
    }
    
    /**
     * List all HTML files for a site
     *
     * @param int $siteId
     * @return array
     */
    public function listSiteHtmlFiles(int $siteId): array
    {
        return $this->s3StorageService->listSiteHtmlFiles($siteId);
    }
    
    /**
     * Delete an HTML file from storage
     *
     * @param string $path
     * @return array
     */
    public function deleteHtml(string $path): array
    {
        return $this->s3StorageService->deleteHtml($path);
    }
    
    /**
     * Save modification history
     *
     * @param int $siteId
     * @param int|null $pageId
     * @param string $title
     * @param string $prompt
     * @param string|null $originalHtml
     * @param string $modifiedHtml
     * @param string|null $sessionId
     * @param array|null $metadata
     * @return \Prasso\BedrockHtmlEditor\Models\HtmlModification
     */
    public function saveModificationHistory(
        int $siteId,
        ?int $pageId,
        string $title,
        string $prompt,
        ?string $originalHtml,
        string $modifiedHtml,
        ?string $sessionId = null,
        ?array $metadata = null,
        ?int $userId = null
    ): \Prasso\BedrockHtmlEditor\Models\HtmlModification {
        // User ID can be passed in or will be null if not authenticated
        
        $modification = new \Prasso\BedrockHtmlEditor\Models\HtmlModification([
            'user_id' => $userId,
            'site_id' => $siteId,
            'page_id' => $pageId,
            'title' => $title,
            'prompt' => $prompt,
            'original_html' => $originalHtml,
            'modified_html' => $modifiedHtml,
            'session_id' => $sessionId,
            'metadata' => $metadata,
        ]);
        
        $modification->save();
        
        Log::info('Saved HTML modification history', [
            'id' => $modification->id,
            'site_id' => $siteId,
            'page_id' => $pageId
        ]);
        
        return $modification;
    }
    
    /**
     * Get modification history for a page
     *
     * @param int $siteId
     * @param int|null $pageId
     * @param int $limit
     * @param int $offset
     * @return array
     */
    public function getModificationHistory(int $siteId, ?int $pageId = null, int $limit = 10, int $offset = 0): array
    {
        try {
            $query = \Prasso\BedrockHtmlEditor\Models\HtmlModification::query()
                ->where('site_id', $siteId)
                ->orderBy('created_at', 'desc')
                ->limit($limit)
                ->offset($offset);
                
            if ($pageId) {
                $query->where('page_id', $pageId);
            }
            
            $modifications = $query->get();
            $total = \Prasso\BedrockHtmlEditor\Models\HtmlModification::where('site_id', $siteId)
                ->when($pageId, function($query) use ($pageId) {
                    return $query->where('page_id', $pageId);
                })
                ->count();
            
            return [
                'success' => true,
                'modifications' => $modifications,
                'total' => $total,
                'limit' => $limit,
                'offset' => $offset,
            ];
        } catch (\Exception $e) {
            Log::error('Failed to retrieve modification history', [
                'error' => $e->getMessage(),
                'site_id' => $siteId,
                'page_id' => $pageId
            ]);
            
            return [
                'success' => false,
                'error' => 'Failed to retrieve modification history: ' . $e->getMessage(),
            ];
        }
    }
}
